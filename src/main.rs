#[macro_use]
mod parser;

mod example;
mod example_macro;
mod property;

use std::process::ExitCode;

use clap::{command, Parser, ValueEnum};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    source: String,
    #[arg(long, value_enum, default_value_t = ParserMode::Macro)]
    parser: ParserMode,
    #[arg(long)]
    show_cache: bool,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum ParserMode {
    /// Use parser generated by the peg! macro.
    Macro,
    /// Use hand written parser using parse! macro.
    Functional,
}

fn main() -> ExitCode {
    let args = Args::parse();
    let parse_fn: Box<dyn Fn(&str) -> parser::ParseRes<isize>> = match args.parser {
        ParserMode::Macro => Box::new(|source: &str| {
            let source: Vec<char> = source.chars().collect();
            let cache = vec![example_macro::DerivationTest::default(); source.len()];
            let mut sess = parser::Session {
                source: &source,
                cache,
            };
            let res = example_macro::DerivationTest::parse_with_session(&mut sess);
            if args.show_cache {
                println!("Session's cache after is {:#?}", sess.cache);
            }
            res
        }),
        ParserMode::Functional => Box::new(|source: &str| {
            let res = example::parse_expr(source);
            if args.show_cache {
                println!("SHOW CACHE NOT SUPORRTED FOR FUNCTIONAL PARSER");
            }
            res
        }),
    };
    match parse_fn(&args.source) {
        parser::ParseRes::Parsed { val, .. } => {
            println!("{val}");
            ExitCode::SUCCESS
        }
        parser::ParseRes::NoParse => {
            eprintln!("Could not parse successfully");
            ExitCode::FAILURE
        }
    }
}
